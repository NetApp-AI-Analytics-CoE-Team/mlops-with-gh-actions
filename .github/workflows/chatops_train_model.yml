name: ChatOps for training AI/ML model
on: [issue_comment]

jobs:
  detect_pr_comments:
    runs-on: self-hosted
    outputs: 
      commit_sha: ${{ steps.output_sha.outputs.sha }}
    steps:
      # using below actions
      # https://github.com/marketplace/actions/chatops-for-pull-requests
      - name: listen for PR Comments (train)
        id: prcomm_train
        uses: machine-learning-apps/actions-chatops@master
        with:
          APP_PEM: ${{ secrets.APP_PEM }}
          APP_ID: ${{ secrets.APP_ID }}
          TRIGGER_PHRASE: "/train-model"
          INDICATOR_LABEL: "chatops-model-training"
        env: # you must supply GITHUB_TOKEN
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      # if PR comment does not match, abort this job
      - name: prcomm_check
        if: steps.prcomm_train.outputs.BOOL_TRIGGERED == 'false'
        run: /bin/bash -c false
      # output variables for following jobs
      - id: output_sha
        run: echo "sha=${{ steps.prcomm_train.outputs.SHA }}" >> $GITHUB_OUTPUT
  # build, upload, and run pipeline based on commited source code
  initiate-model-training-run:
    runs-on: self-hosted
    needs: detect_pr_comments
    environment:
      name: Training
    outputs:
      run_id: ${{ steps.output_run_id.outputs.run_id }}
    steps:
      # This step clones the branch of the PR associated with the triggering phrase, but only if it is triggered.
      - name: clone branch of PR
        uses: actions/checkout@master
        with:
          ref: ${{ needs.detect_pr_comments.outputs.SHA }}
      # building pipeline package
      # expects pipeline function is declared in "./pipline.py"
      - name: build pipeline
        run: python3 ./pipeline.py ./pipeline.yaml
      - name: deploy and run pipeline
        id: train_launcher
        run: |
          python3 ./github_actions/deploy_pipeline.py \
            --k8s-context=${{ secrets.K8S_CONTEXT }} \
            --kf-endpoint=${{ secrets.KUBEFLOW_ENDPOINT }} \
            --kf-username=${{ secrets.KUBEFLOW_USERNAME }} \
            --kf-password=${{ secrets.KUBEFLOW_PASSWORD }} \
            --namespace=${{ secrets.NAMESPACE }} \
            --kf-experiment-name=${{ secrets.KUBEFLOW_EXPERIMENT_NAME }} \
            --pipeline-package-path=pipeline.yaml \
            --pipeline-version=${{ needs.detect_pr_comments.outputs.commit_sha }} \
            --output-file=tmp_run_id.txt
      - id: output_run_id
        run: echo "run_id=`cat tmp_run_id.txt`" >> $GITHUB_OUTPUT
  # nortify result of building/uploading/running pipeline as a PR comment
  initiate-model-training-run-result:
    runs-on: self-hosted
    if: ${{ always() }}
    needs: 
      - detect_pr_comments
      - initiate-model-training-run
    environment:
      name: Training
    steps:
      # in case of succeeded
      - name: setup comment message (success)
        if: ${{ needs.initiate-model-training-run.result == 'success' }}
        id: success_comment
        run: |
          lf='\n'
          message="## :pushpin: Actions Result - Build, Deploy and Create ML pipeline Run"
          message+="${lf}:rocket: Successfully launched the pipeline for commit: \`${{ needs.detect_pr_comments.outputs.commit_sha }}\`"
          message+="<br />"
          message+="${lf}You will be notified when the pipeline RUN is completed or exceeded timeout."
          message+="${lf}Or you can check detailed status of RUN in Kubeflow UI using below informations."
          message+="${lf}## :runner: Run information"
          message+="${lf}Kubeflow UI: ${{ secrets.KUBEFLOW_ENDPOINT }}"
          message+="${lf}Kubeflow Profile(k8s namespace): ${{ secrets.NAMESPACE }}"
          message+="${lf}RUN ID: ${{ needs.initiate-model-training-run.outputs.run_id }}"
          echo "message=${message}" >> $GITHUB_OUTPUT
      - name: commenting on PR (success) 
        if: ${{ needs.initiate-model-training-run.result == 'success' }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const params = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '${{ steps.success_comment.outputs.message }}'
            }
            await github.rest.issues.createComment(params)
      # in case of failed
      - name: setup comment message (failure)
        if: ${{ needs.initiate-model-training-run.result == 'failure' }}
        id: failure_comment
        run: |
          lf='\n'
          message="## :pushpin: Actions Result - Build, Deploy and Create ML pipeline Run"
          message+="${lf}:x: Failed to launch the pipeline for commit: \`${{ needs.detect_pr_comments.outputs.commit_sha }}\`"
          message+="<br />"
          message+="${lf}Check Actions tab and Kubeflow UI to find the error cause."  
          message+="${lf}Kubeflow UI: ${{ secrets.KUBEFLOW_ENDPOINT }}"
          echo "message=${message}" >> $GITHUB_OUTPUT
      - name: commenting on PR (failure) 
        if: ${{ needs.initiate-model-training-run.result == 'failure' }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const params = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '${{ steps.failure_comment.outputs.message }}'
            }
            await github.rest.issues.createComment(params)
  # wait for completion of pipline RUN that is initiated previous job
  # default timeout is 5 hours
  wait-for-run-completion:
    runs-on: self-hosted
    needs: 
      - detect_pr_comments
      - initiate-model-training-run
      - initiate-model-training-run-result
    environment:
      name: Training
    outputs: 
      run_status: ${{ steps.output_run_status.outputs.run_status }}
    steps:
      - name: clone branch of PR
        uses: actions/checkout@master
        with:
          ref: ${{ needs.detect_pr_comments.outputs.commit_sha }}
      - name: wait for pipeline run
        id: run_waiter
        run: | 
          python3 ./github_actions/wait_run_completion.py \
            --k8s-context=${{ secrets.K8S_CONTEXT }} \
            --kf-endpoint=${{ secrets.KUBEFLOW_ENDPOINT }} \
            --kf-username=${{ secrets.KUBEFLOW_USERNAME }} \
            --kf-password=${{ secrets.KUBEFLOW_PASSWORD }} \
            --namespace=${{ secrets.NAMESPACE }} \
            --run-id=${{ needs.initiate-model-training-run.outputs.run_id }} \
            --output-file=tmp_run_status.txt
      - id: output_run_status
        run: echo "run_status=`cat tmp_run_status.txt`" >> $GITHUB_OUTPUT
  # nortify result of pipeline RUN as a PR comment
  # also in case of "succeeded", get artifact uri that is uploaded into the artifact repository
  wait-for-run-completion-result:
    runs-on: self-hosted
    needs:
      - detect_pr_comments
      - initiate-model-training-run
      - wait-for-run-completion
    environment:
      name: Training
    steps:
      - name: clone branch of PR
        uses: actions/checkout@master
        with:
          ref: ${{ needs.detect_pr_comments.outputs.commit_sha }}
      # in case of succeeded
      # get model uri from pipeline RUN
      - name: read artifact of run (model uri)
        if: needs.wait-for-run-completion.outputs.run_status == 'Succeeded'
        run: |
          python3 ./github_actions/read_pipeline_output.py \
            --k8s-context=${{ secrets.K8S_CONTEXT }} \
            --kf-endpoint=${{ secrets.KUBEFLOW_ENDPOINT }} \
            --kf-username=${{ secrets.KUBEFLOW_USERNAME }} \
            --kf-password=${{ secrets.KUBEFLOW_PASSWORD }} \
            --namespace=${{ secrets.NAMESPACE }} \
            --run-id=${{ needs.initiate-model-training-run.outputs.run_id }} \
            --component-name=upload-savedmodel \
            --artifact-name=upload-savedmodel-Output \
            --output-file=tmp_model_uri.txt
      - id: output_model_uri
        if: needs.wait-for-run-completion.outputs.run_status == 'Succeeded'
        run: echo "model_uri=`cat tmp_model_uri.txt`" >> $GITHUB_OUTPUT
      # get dataset version name from pipeline RUN
      - name: read artifact of run (dataset version)
        if: needs.wait-for-run-completion.outputs.run_status == 'Succeeded'
        run: |
          python3 ./github_actions/read_pipeline_output.py \
            --k8s-context=${{ secrets.K8S_CONTEXT }} \
            --kf-endpoint=${{ secrets.KUBEFLOW_ENDPOINT }} \
            --kf-username=${{ secrets.KUBEFLOW_USERNAME }} \
            --kf-password=${{ secrets.KUBEFLOW_PASSWORD }} \
            --namespace=${{ secrets.NAMESPACE }} \
            --run-id=${{ needs.initiate-model-training-run.outputs.run_id }} \
            --component-name=create-snapshot \
            --artifact-name=create-snapshot-Output \
            --output-file=tmp_dataset_version.txt
      - id: output_dataset_version
        if: needs.wait-for-run-completion.outputs.run_status == 'Succeeded'
        run: echo "dataset_version=`cat tmp_dataset_version.txt`" >> $GITHUB_OUTPUT
      # commenting on PR
      - name: setup comment message (Succeeded)
        if: needs.wait-for-run-completion.outputs.run_status == 'Succeeded'
        id: success_comment
        run: | 
          lf='\n'
          message="## :pushpin: Actions Result - Result of ML Pipeline Run"
          message+="${lf}:white_check_mark: Pipeline RUN: \`${{ needs.initiate-model-training-run.outputs.run_id }}\` has been successfully completed."
          message+="${lf}## :brain: Model information"
          message+="${lf}Model package is stored in the artifact repository."
          message+="<br />"
          message+="${lf}Artifact URI: ${{ steps.output_model_uri.outputs.model_uri }}"
          message+="${lf}## :mag: How to reproduce the model"
          message+="${lf}To reproduce this model, you can create a Jupyter Workspace which contains source code, hyper parameters, and dataset version by performing following tasks"
          message+="<br /><details>"
          message+="<summary>show procedure</summary>"
          message+="${lf}1. Login to workstation which can access to k8s API"
          message+="${lf}2. Restore dataset version by using NetApp DataOps Tooklkit"
          message+="${lf}\`\`\`bash"
          message+="${lf}# Install NetApp DataOps Toolkit"
          message+="${lf}$ python3 -m pip install netapp-dataops-k8s"
          message+="${lf}"
          message+="${lf}# Clone PVC from snapshot that was taken at model training"
          message+="${lf}$ netapp_dataops_k8s_cli.py clone volume --namespace=${{ secrets.NAMESPACE }} --source-snapshot-name=${{ steps.output_dataset_version.outputs.dataset_version }} --new-pvc-name=clone-${{ steps.output_dataset_version.outputs.dataset_version }}"
          message+="${lf}\`\`\`"
          message+="${lf}3. Create Jupyter workspace with cloned PVC by using NetApp DataOps Toolkit"
          message+="${lf}\`\`\`bash"
          message+="${lf}# Create Jupyter workspace using cloned PVC"
          message+="${lf}$ netapp_dataops_k8s_cli.py create jupyterlab --namespace=${{ secrets.NAMESPACE }} --workspace-name=reproduce-${{ needs.initiate-model-training-run.outputs.run_id }} --size=10Gi --mount-pvc=clone-${{ steps.output_dataset_version.outputs.dataset_version }} --nvidia-gpu=1"
          message+="${lf}\`\`\`"
          message+="${lf}4. Connect the workspace provisioned by NetApp DataOps Tooklkit"
          message+="${lf}You can find Workspace URL in result of \`netapp_dataops_k8s_cli.py create jupyterlab\` command."
          message+="${lf}5. Resotre the source code and hyper parameters from GitHub commit"
          message+="${lf}\`\`\`bash"
          message+="${lf}# Open a terminal in Jupyter Workspace and execute below commandline"
          message+="${lf}$ git clone ${{ github.repository }} ."
          message+="${lf}$ git reset -hard ${{ needs.detect_pr_comments.outputs.commit_sha }}"
          message+="${lf}\`\`\`"
          message+="</details>"
          echo "message=${message}" >> $GITHUB_OUTPUT
      - name: commenting on PR (Succeeded) 
        if: needs.wait-for-run-completion.outputs.run_status == 'Succeeded'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const params = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '${{ steps.success_comment.outputs.message }}'
            }
            await github.rest.issues.createComment(params)
      - name: applying label (Succeeded)
        if: needs.wait-for-run-completion.outputs.run_status == 'Succeeded'
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ["model-is-ready"]
            })
      # in case of run failed
      - name: commenting on PR (Failed) 
        if: needs.wait-for-run-completion.outputs.run_status == 'Failed'
        id: failed_comment
        run: | 
          lf='\n'
          message="## :pushpin: Actions Result - Result of ML Pipeline Run"
          message+="${lf}:x: Pipeline RUN: \`${{ needs.initiate-model-training-run.outputs.run_id }}\` has been completed with failure."
          message+="<br />"
          message+="Check detailed status of pipeline RUN in Kubeflow UI"
          message+="${lf}## :runner: Run information"
          message+="${lf}Kubeflow Endpoint: ${{ needs.initiate-model-training-run.outputs.kubeflow_url }}"
          message+="${lf}Kubeflow Profile(k8s namespace): ${{ secrets.NAMESPACE }}"
          message+="${lf}RUN ID: ${{ needs.initiate-model-training-run.outputs.run_id }}"
          echo "message=${message}" >> $GITHUB_OUTPUT      
      - name: commenting on PR (Failed) 
        if: needs.wait-for-run-completion.outputs.run_status == 'Failed'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const params = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '${{ steps.failed_comment.outputs.message }}'
            }
            await github.rest.issues.createComment(params)
      # in case of run timeouted
      - name: commenting on PR (timeout) 
        if: needs.wait-for-run-completion.outputs.run_status == 'TimeoutError'
        id: timeout_comment
        run: | 
          lf='\n'
          message="## :pushpin: Actions Result - Result of ML Pipeline Run"
          message+="${lf}:x: Pipeline RUN: \`${{ needs.initiate-model-training-run.outputs.run_id }}\` has exceeded timeout and NOT been completed yet."
          message+="<br />"
          message+="Check detailed status of pipeline RUN in Kubeflow UI"
          message+="${lf}## :runner: Run information"
          message+="${lf}Kubeflow Endpoint: ${{ needs.initiate-model-training-run.outputs.kubeflow_url }}"
          message+="${lf}Kubeflow Profile(k8s namespace): ${{ secrets.NAMESPACE }}"
          message+="${lf}RUN ID: ${{ needs.initiate-model-training-run.outputs.run_id }}"
          echo "message=${message}" >> $GITHUB_OUTPUT      
      - name: commenting on PR (timeout) 
        if: needs.wait-for-run-completion.outputs.run_status == 'TimeoutError'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const params = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '${{ steps.timeout_comment.outputs.message }}'
            }
            await github.rest.issues.createComment(params)